---
title: コンテナー内の永続的なストレージ
description: Windows コンテナーで永続的なストレージを使用する方法
keywords: コンテナー, ボリューム, 記憶域, マウント, bindmount
author: cwilhit
ms.openlocfilehash: 945a78d4ecb9c96da4de8f7246f84b6b444dd5b5
ms.sourcegitcommit: 22dcc1400dff44fb85591adf0fc443360ea92856
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/12/2019
ms.locfileid: "10209888"
---
# <a name="persistent-storage-in-containers"></a>コンテナー内の永続的なストレージ

<!-- Great diagram would be great! -->

アプリがコンテナー内のデータを保持できることが重要である場合や、コンテナーのビルド時に含まれていないコンテナーにファイルを表示したい場合があります。 コンテナーには、次の2つの方法で永続的なストレージを割り当てることができます。

- バインド マウント
- 名前付きボリューム

Docker には、[ボリュームの使用](https://docs.docker.com/engine/admin/volumes/volumes/)に関する概要が用意されているため、まずそのドキュメントをご覧ください。 このページの残りの部分では、Linux と Windows の違いについて説明し、Windows の場合の例を示します。

## <a name="bind-mounts"></a>バインド マウント

[バインド マウント](https://docs.docker.com/engine/admin/volumes/bind-mounts/)を使用すると、コンテナーがディレクトリをホストと共有できます。 この方法は、コンテナーを再起動したときに使用可能なローカル コンピューター上のファイルを保存する場所が必要な場合や、複数のコンテナーと共有する場合に有効です。 コンテナーを複数のコンピューターで実行して同じファイルにアクセスする場合は、代わりに名前付きボリュームまたは SMB マウントを使用する必要があります。

### <a name="permissions"></a>アクセス許可

バインド マウントに使用されるアクセス許可モデルは、コンテナーの分離レベルによって異なります。

**Hyper-v 分離**を使っているコンテナーは、シンプルな読み取り専用または読み取り/書き込みのアクセス許可モデルを使用します。 ホスト上のファイル アクセスには `LocalSystem` アカウントを使用します。 コンテナーに対するアクセスが拒否される場合は、ホスト上のそのディレクトリに `LocalSystem` からのアクセス許可があることを確認してください。 読み取り専用フラグが使用された場合、コンテナー内のボリュームへの変更はホスト上のディレクトリに永続化または表示されません。

**プロセスの分離**を使う Windows コンテナーは、コンテナー内のプロセス id を使用してデータにアクセスするため (ファイルの acl が有効であることを意味します)、若干異なります。 マウントされたボリューム内のファイルとディレクトリへのアクセスには、`LocalSystem` ではなく、コンテナーで実行されているプロセスの ID (既定で Windows サーバー コアの場合は "ContainerAdministrator"、Nano Server コンテナーの場合は "ContainerUser") が使用され、データを使用するにはアクセス権が必要になります。

これらの id は、ファイルが格納されているホスト上ではなく、コンテナーのコンテキスト内にのみ存在するため、コンテナーへのアクセス権を付与`Authenticated Users`するように acl を構成するときなど、既知のセキュリティグループを使用する必要があります。

> [!WARNING]
> `C:\` などの機密性の高いディレクトリは、信頼されていないコンテナーにバインド マウントしないでください。 このようなバインド マウントを行うと、通常はアクセスできないホスト上のファイルへの変更が許可され、セキュリティ侵害が生じる可能性があります。

使用例:

- `docker run -v c:\ContainerData:c:\data:RO` (読み取り専用アクセス用)
- `docker run -v c:\ContainerData:c:\data:RW` (読み取り/書き込みアクセス用)
- `docker run -v c:\ContainerData:c:\data` (読み取り/書き込みアクセス用、既定)

### <a name="symlinks"></a>symlink

symlink は、コンテナ内で解決されます。 symlink であるコンテナーまたは symlink を含むコンテナーにホスト パスをバインド マウントしても、コンテナーではこれらの symlink にアクセスできません。

### <a name="smb-mounts"></a>SMB マウント

Windows Server バージョン1709以降では、"SMB グローバルマッピング" と呼ばれる機能を使用すると、ホストに SMB 共有をマウントし、その共有上のディレクトリをコンテナーに渡すことができます。 コンテナーは、特定のサーバー、共有、ユーザー名、またはパスワードを指定して構成する必要はありません。これはすべてホストで処理されます。 コンテナーは、ローカル記憶域がある場合と同様に機能します。

#### <a name="configuration-steps"></a>構成手順

1. コンテナーホストでは、次のように、リモート SMB 共有をグローバルにマップします。
    ```
    $creds = Get-Credential
    New-SmbGlobalMapping -RemotePath \\contosofileserver\share1 -Credential $creds -LocalPath G:
    ```
    このコマンドは、資格情報を使ってリモート SMB サーバーで認証します。 次に、リモート共有パスを G: ドライブ文字にマップします (その他の使用可能なドライブ文字も指定できます)。 このコンテナー ホストで作成されたコンテナーでは、自身のデータ ボリュームを G: ドライブ上のパスにマップできます。

    > [!NOTE]
    > コンテナーの SMB グローバルマッピングを使用している場合、コンテナーホストのすべてのユーザーがリモート共有にアクセスできます。 コンテナー ホストで実行されているすべてのアプリケーションにも、マッピングされたリモート共有へのアクセス権があります。

2. グローバルにマウントされた SMB 共有んいマップされたデータ ボリュームを使用してコンテナーを作成します: docker run -it --name demo -v g:\ContainerData:G:\AppData1 microsoft/windowsservercore:1709 cmd.exe

    コンテナー内で、G:\AppData1 はリモート共有の "ContainerData" ディレクトリにマップされます。 グローバルにマップされたリモート共有に格納されているデータは、コンテナー内のアプリケーションで使用できるようになります。 複数のコンテナーが同じコマンドを使用して、この共有データへの読み取り/書き込みアクセス権を獲得することもできます。

この SMB グローバル マッピングは、互換性のある SMB サーバー上で動作できる SMB クライアント側の機能によってサポートされます。次のようなものがあります。

- 記憶域スペース ダイレクト (S2D) 上のスケール アウト ファイル サーバーまたは従来の SAN
- Azure Files (SMB 共有)
- 従来のファイル サーバー
- SMB プロトコルのサード パーティ実装 (例: NAS アプライアンス)

> [!NOTE]
> SMB グローバル マッピングでは、Windows Server Version 1709 の DFS、DFSN、および DFSR 共有がサポートされていません。

## <a name="named-volumes"></a>名前付きボリューム

名前付きボリュームの機能を使用すると、名前を指定してボリュームを作成し、コンテナーに割り当てて、同じ名前で後で再利用できます。 作成時の実際のパスを追跡する必要はなく、名前だけを使用します。 Windows 上の Docker エンジンには、ローカル コンピューター上にボリュームを作成できる、組み込みの名前付きボリューム プラグインがあります。 複数のコンピューターで名前付きボリュームを使用する場合は、追加のプラグインが必要です。

手順の例:

1. `docker volume create unwound` - 'unwound' という名前のボリュームを作成します。
2. `docker run -v unwound:c:\data microsoft/windowsservercore` - c:\data にマップされているボリュームでコンテナーを開始します。
3. コンテナー内の c:\data にいくつかのファイルを書き込み、コンテナーを停止します。
4. `docker run -v unwound:c:\data microsoft/windowsservercore` - 新しいコンテナーを開始します。
5. 新しいコンテナー内で `dir c:\data` を実行します。ここにはまだファイルが含まれています。

> [!NOTE]
> Windows Server はターゲットのパス名 (コンテナー内のパス) を小文字に変換します。i `-v unwound:c:\MyData`、または`-v unwound:/app/MyData` linux コンテナーでは、コンテナー `c:\mydata`内または`/app/mydata` linux コンテナー内に、マップされている (存在しない場合は作成される) ディレクトリが表示されます。
